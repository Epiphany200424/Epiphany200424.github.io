{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Epiphany","url":"http://example.com","root":"/"},"pages":[{"title":"友链","date":"2020-11-29T09:18:06.000Z","updated":"2022-10-28T14:21:30.143Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-29T09:18:06.000Z","updated":"2022-10-28T12:16:40.803Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"1234567891011121314151617181920&#123; about: &#123; name: &quot;陶广&quot;, age: 18, gender: &quot;男&quot;, experience: &quot;0年&quot;, address: &quot;重庆&quot;, education: &quot;不告诉你哦&quot;, email: &quot;2121984276@qq.com&quot;, description: &quot;致力于Java, 以及前沿的思潮下进步&quot;, &#125;, skills: [ [&quot;Html&quot;, &quot;Javascript&quot;, &quot;CSS&quot;, &quot;ES6&quot;], [&quot;Git&quot;], [&quot;Vue.js&quot;,&quot;Jquery&quot;], [&quot;ElementUI&quot;, &quot;bootstrap&quot;], [&quot;Java&quot;, &quot;Spring&quot;, &quot;MyBatis&quot;], [&quot;Linux&quot;] ]&#125;"},{"title":"分类","date":"2020-11-29T09:18:06.000Z","updated":"2022-10-28T12:16:23.506Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-29T09:18:06.000Z","updated":"2022-10-28T12:16:33.262Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"项目","date":"2020-11-29T09:18:06.000Z","updated":"2022-10-28T12:16:27.891Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Boot 核心功能","slug":"核心功能","date":"2022-10-29T08:10:00.000Z","updated":"2022-10-29T08:10:45.055Z","comments":true,"path":"2022/10/29/核心功能/","link":"","permalink":"http://example.com/2022/10/29/%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/","excerpt":"","text":"Spring Boot 核心功能","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://example.com/tags/Spring-Boot/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Spring Boot 配置文件","slug":"Spring Boot 配置文件","date":"2022-10-28T09:12:49.134Z","updated":"2022-10-28T10:35:34.662Z","comments":true,"path":"2022/10/28/Spring Boot 配置文件/","link":"","permalink":"http://example.com/2022/10/28/Spring%20Boot%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/","excerpt":"","text":"文件类型properties和以前 application.properties 是一样的写法 yaml简介YAML 是 “YAML Ain&#96;t Markup Language”(YAML 不是一种标记语言)在开发时 它仍然是一种标记语言简介里的这句话，表达的意思是YAML注重的应是数据本身，而不是以标记语言为重点 基本语法 key : value ( 特别注意的是 key 和 value之间要有空格分隔 ) 大小写敏感 使用缩进来表示层级关系 缩进不允许使用tab，只允许空格 缩进的空格数不重要，只要相同层级的元素左对齐即可 和 properties文件一样 也是用 ‘#’ 表示注释的 ‘ ‘与”” 表示字符串内容 会被 转义&#x2F;不转移 数据类型示例配置提示","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://example.com/categories/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://example.com/tags/Spring-Boot/"},{"name":"知识点","slug":"知识点","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"SpringBoot2自动配置入门","slug":"SpringBoot2自动配置入门","date":"2022-10-28T07:37:42.000Z","updated":"2022-10-28T12:43:01.264Z","comments":true,"path":"2022/10/28/SpringBoot2自动配置入门/","link":"","permalink":"http://example.com/2022/10/28/SpringBoot2%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8/","excerpt":"","text":"SpringBoot特点依赖管理 父项目做依赖管理 1234567891011121314151617依赖管理 &lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&lt;version&gt;2.7.3&lt;/version&gt;&lt;/parent&gt;他的父项目&lt;parent&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;&lt;version&gt;2.7.3&lt;/version&gt;&lt;/parent&gt;几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制 开发导入starter场景启动器 官网说明: https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters 1234567891011121、见到很多 spring-boot-starter-* ： *就某种场景2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入3、SpringBoot所有支持的场景https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter4、见到的 *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。5、所有场景启动器最底层的依赖&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;version&gt;2.7.3&lt;/version&gt;&lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; 无需关注版本号，自动版本仲裁 121、引入依赖默认都可以不写版本2、引入非版本仲裁的jar，要写版本号。 可以修改默认版本号 123451、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。2、在当前项目里面重写配置&lt;properties&gt;&lt;mysql.version&gt;5.1.43&lt;/mysql.version&gt;&lt;/properties&gt; 自动配置 自动配置好的tomcat 引入tomcat依赖 配置tomcat123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 自动配置好的SpringMVC 引入SpringMVC全套组件 自动配好SpringMVC常用组件（功能） 例如： 前端控制器DispatcherServlet：拦截所有的前端的请求； 字符编码characterEncodingFilter：解决返回中文字符串乱码问题； 视图解析器viewResolver：对返回的视图进行渲染呈现； 文件上传解析器multipatResolver：文件上传； 123456789public static void main(String[] args) &#123; //1. 返回IOC容器 ConfigurableApplicationContext run = SpringApplication.run(ManApplication.class, args); //2. 查看容器中的组件 String[] names = run.getBeanDefinitionNames(); for (String name : names) &#123; System.out.println(Arrays.toString(names)); &#125; &#125; 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.22&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; 自动配好web常见的功能，如字符编码问题 Spring Boot 帮我们配置好了所有web开发时需要的场景 默认包结构 主程序所在的包都会被及其下边的所有子包里面的组件都会被扫描进来 无需以前的包扫描配置 如果想要改变扫描路径,那就可以使用 主程序上的注解 @SpringBootApplication(scanBasePackages &#x3D; “需要扫描包的路径”) 或者也可以 使用 注解 **@ComponentScan **扫描路径1234@SpringBootApplication 注解等同于下面三个注解@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(&#123;&quot;指定的包扫描路径&quot;&#125;) 各种配置拥有默认值 默认配置最终都是映射到某一个类上的 xxxProperties .java文件中 配置文件的值最终会绑定到某个类上。这个类会在容器中有创建对象 按需加载所有自动配置项 非常多的starter 引入了哪些场景这个场景的自动配置才会开启 Spring Boot 所有的自动配置功能都在spring-boot-autoconfigure包中123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; ….. 容器功能组件添加@Configuration 可以理解为一个Configuration就是对应的一个Spring的xml版的容器当@Configuration使用在类上时 注解中的属性 proxyBeanMethods 属性默认会为 true，则组件默认会为单例模式的 简单来说就是 proxyBeanMethods属性默认值是true,也就是说该配置类会被代理（CGLIB），在同一个配置文件中调用其它被@Bean注解标注的方法获取对象时会直接从IOC容器之中获取, 也开始单例模式；注解的意思是proxyBeanMethods配置类是用来指定@Bean注解标注的方法是否使用代理，默认是true使用代理，直接从IOC容器之中取得对象；如果设置为false,也就是不使用注解，每次调用@Bean标注的方法获取到的对象和IOC容器中的都不一样，是一个新的对象，所以我们可以将此属性设置为false来提高性能； Full 模式 和 Lite 模式 的区别 Full 全配置(proxyBeanMethods &#x3D; true )保证每个@Bean方法被调用多少次返回的组件都是单实例的 Lite 轻量级配置 (proxyBeanMethods &#x3D; false)每个@Bean方法被调用多少次返回的组件都是新创建的配置 类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#############################Configuration使用示例######################################################/** * @author 陶广 * @Configuration 告诉SpringBoot这是一个配置类 == ssm中的配置文件 * 1. 使用@Bean注解在方法上，在IOC容器中提供配置类方式祖册的组件默认都是单例模式 * 2. 被 @Configuration注解的类也会在SpringBoot中成为一个组件 * 3. proxyBeanMethods属性:代理bean的方法 * Full(全配置 proxyBeanMethods = true ) [保证每个@Bean方法被调用多少次返回的组件都是单实例的]、 * Lite(轻量级配置 proxyBeanMethods = false) [每个@Bean方法被调用多少次返回的组件都是新创建的] * 组件依赖必须使用Full模式默认。其他默认是否Lite模式 */@Configuration(proxyBeanMethods = false)public class MyConfig &#123; /** * 给容器中添加组件，以方法名作为组件的id，返回值就是组件类型，方法返回的对象就相当于在IOC容器中的实例 */ @Bean() public User user01() &#123; User zhangsan = new User(&quot;张三&quot;, 18); //这里user组件依赖了pet组件 zhangsan.setPet(pet()); return zhangsan; &#125; @Bean(&quot;tomcat&quot;) public Pet pet() &#123; return new Pet(&quot;tomcat&quot;); &#125;&#125;#############################Configuration测试代码######################################################/** * 主程序类 * @SpringBootApplication 告诉SpringBoot这是一个SpringBoot应用 *///@SpringBootApplication(scanBasePackages = &quot;com.tao&quot;)@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(&#123;&quot;com.tao&quot;&#125;)public class ManApplication &#123; public static void main(String[] args) &#123; //1. 返回IOC容器 ConfigurableApplicationContext run = SpringApplication.run(ManApplication.class, args); //2. 查看容器中的组件// String[] names = run.getBeanDefinitionNames();// for (String name : names) &#123;// System.out.println(Arrays.toString(names));// &#125; //3. 从容器中获取组件,在IOC容器中提供配置类方式祖册的组件默认都是单例模式 User user01 = run.getBean(&quot;user01&quot;,User.class); User user02 = run.getBean(&quot;user01&quot;,User.class); System.out.println(user01 == user02); //4. com.tao.boot.config.MyConfig$$EnhancerBySpringCGLIB$$7cdb6c6c@648ee871 MyConfig bean = run.getBean(MyConfig.class); System.out.println(bean); //5. 如果 @Configuration 注解 的 属性 proxyBeanMethods = true 则SpringBoot总会检查这个组件是否在IOC容器中存在 //存在则不会创建新的对象,会使用之前的对象,保持单例模式 User user = bean.user01(); User user1 = bean.user01(); System.out.println(user == user1); //6.如果 组件 为 Lite模式 则 组件之间的依赖时不会相等的 //为Full模式之间之间的依赖会相等 User bean1 = run.getBean(User.class); Pet pet = run.getBean(Pet.class); System.out.println(&quot;组件依赖是否相等&quot; + (bean1.getPet() == pet)); &#125;&#125; @Bean、@Component、@Controller、@Service、@Repository@Import导入装配：将需要的注册的bean对象组件注入(必须全名) 1234567@Import(&#123;User.class, DBHelper.class&#125;)//给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名@Import(&#123;User.class, DBHelper.class&#125;)@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件public class MyConfig &#123;&#125; 4.@Conditional条件装配：满足Conditional指定的条件，则进行组件注入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#############################Conditional使用示例######################################################@Import(&#123;DBHelper.class&#125;)@Configuration(proxyBeanMethods = true)//@ConditionalOnBean(name = &quot;user01&quot;) //当IOC容器中有 名为 user01 的组件时则 创建该组件@ConditionalOnMissingBean(name = &quot;user01&quot;)//当IOC容器中没有 名为 user01 的组件时则 创建该组件public class MyConfig &#123; @Bean(&quot;tomcat&quot;) public Pet pet() &#123; return new Pet(&quot;tomcat&quot;); &#125; /** * 给容器中添加组件，以方法名作为组件的id，返回值就是组件类型，方法返回的对象就相当于在IOC容器中的实例 */ @ConditionalOnBean(name = &quot;tomcat&quot;) @Bean(&quot;user01&quot;) public User user01() &#123; User zhangsan = new User(&quot;张三&quot;, 18); //这里user组件依赖了pet组件 zhangsan.setPet(pet()); return zhangsan; &#125;&#125;#############################Conditional测试代码#####################################################@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(&#123;&quot;com.tao&quot;&#125;)public class ManApplication &#123; public static void main(String[] args) &#123; //1. 返回IOC容器 ConfigurableApplicationContext run = SpringApplication.run(ManApplication.class, args); //7. 判断配置类(组件)中 是否包含某个组件 boolean tomcat = run.containsBean(&quot;tomcat&quot;); System.out.println(&quot;容器中的tomcat组件:&quot;+ tomcat); boolean tomcat22 = run.containsBean(&quot;tomcat22&quot;); System.out.println(&quot;容器中的tomcat22组件:&quot;+ tomcat22); boolean user01 = run.containsBean(&quot;user01&quot;); System.out.println(&quot;容器中的user01组件:&quot;+ user01); &#125;&#125; 原生配置(xml)导入@ImportResource原生配置: 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;test01&quot; class=&quot;com.tao.boot.entity.User&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;测试名称&quot;/&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt; &lt;property name=&quot;pet&quot; ref=&quot;test02&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;test02&quot; class=&quot;com.tao.boot.entity.Pet&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;黄术&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 导入并测试: 12345678@ImportResource(&quot;classpath:beans.xml&quot;)public class MyConfig &#123;&#125;=============测试===================boolean test01 = run.containsBean(&quot;test01&quot;);boolean test02 = run.containsBean(&quot;test02&quot;);System.out.println(&quot;test01:&quot; + test01);System.out.println(&quot;test02:&quot; + test02); 配置绑定如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用； 1234567891011121314public class getProperties &#123; public static void main(String[] args) throws FileNotFoundException, IOException &#123; Properties pps = new Properties(); pps.load(new FileInputStream(&quot;a.properties&quot;)); Enumeration enum1 = pps.propertyNames();//得到配置文件的名字 while(enum1.hasMoreElements()) &#123; String strKey = (String) enum1.nextElement(); String strValue = pps.getProperty(strKey); System.out.println(strKey + &quot;=&quot; + strValue); //封装到JavaBean。 &#125; &#125; &#125; car实体类 123456789101112131415161718192021222324252627282930313233343536373839404142package com.tao.boot.entity;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;public class Car &#123; private String brand; private Double price; public Car() &#123; &#125; public Car(String brand, Double price) &#123; this.brand = brand; this.price = price; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;brand=&#x27;&quot; + brand + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125; 在application.properties中配置实体类的几个字段 12car.brand=BYDcar.price=100000 @ConfigurationProperties + @Component在需要 Properties 的实体类上加上先加上 @Component注册到IOC容器中成为组件，才能使用SpringBoot提供的功能使用前@ConfigurationProperties，需要先指定配置前缀(属性 prefix) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//=========================配置绑定================================== @Component @ConfigurationProperties(prefix = &quot;car&quot;) public class Car &#123; private String brand; private Double price; public Car() &#123; &#125; public Car(String brand, Double price) &#123; this.brand = brand; this.price = price; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;brand=&#x27;&quot; + brand + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125; &#125;//=========================测试代码================================== @RestController public class HelloController &#123; @Resource private Car car; @RequestMapping(&quot;/getCar&quot;) public Car car() &#123; return car; &#125; &#125; @EnableConfigurationProperties + @ConfigurationProperties用springboot开发的过程中，我们会用到**@ConfigurationProperties注解，主要是用来把properties或者yml配置文件转化为bean来使用的，而@EnableConfigurationProperties**注解的作用是@ConfigurationProperties注解生效。如果只配置@ConfigurationProperties注解，在IOC容器中是获取不到properties配置文件转化的bean的，当然在@ConfigurationProperties加入注解的类上加@Component也可以使交于springboot管理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//=============配置绑定==================@ConfigurationProperties(prefix = &quot;car&quot;)public class Car &#123; private String brand; private Double price; public Car() &#123; &#125; public Car(String brand, Double price) &#123; this.brand = brand; this.price = price; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125; public Double getPrice() &#123; return price; &#125; public void setPrice(Double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Car&#123;&quot; + &quot;brand=&#x27;&quot; + brand + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125;//1、开启Car配置绑定功能//2、把这个Car这个组件自动注册到容器中@EnableConfigurationProperties(Car.class)public class MyConfig &#123;&#125; 自动配置入门引导加载自动配置类@SpringBootConfiguration(SpringBoot配置)标注是一个配置类它是 @Configuration 注解的派生类注解它与 @Configuration 注解功能一致区别在于 @Configuration 是Spring 的注解 而@SpringBootConfiguration是SpringBoot的注解 @ComponentScan(组件扫描)@Component 注解及其衍生注解 @RestController、@Controller、@Service、@Repository 都是组件注册注解@ComponentScan 注解主要是从约定的扫描路径中，识别标注了组件注册注解的类，并且把这些类注入到IOC容器中去，这些类就是 Spring 中的bean@Component 也会被IOC容器所托管 组件扫描路径注解@ComponentScan 如果不设置value属性，默认扫描路径是启动类 XxxApplication.java 所在目录及其子目录，所以最好还是配置value属性，减少加载时间，提高系统启动速度。比如启动类在包 com.test.web下面，那么项目启动时，会默认扫描web包及其子包下的所有类。也就是说，即便不明确标注@ComponentScan，Spring Boot也会自动搜索当前应用主入口目录及其下方子目录。如果其它包中的bean 不在当前主包路径下面，则应使用@ComponentScan设置value属性，配置扫描路径。如果定义了错误的扫描路径，那么在使用注解@Autowired自动装配Bean时会出错，报a bean of type that could not be found错误。 配置扫描路径@ComponentScan注解既可以扫描包，也可以扫描指定的类。我们只需要指定一个需要扫描的路径，就可以达到更改扫描路径的目的。 包扫描 通过value属性设置需要扫描bean的包 @ComponentScan({“com.test.mapper”,”com.test.service”})2. 类扫描 通过basePackageClasses属性指定需要扫描的类 @ComponenScan(basePackageClasses&#x3D;{xxxxMapper.class,xxxxController.class}) @EnableAutoConfiguration(启用自动配置)指定了默认的包规则 12@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class) @AutoConfigurationPackage自动配置包，指定了默认的包规则 12345@Import(Registrar.class) //给容器中导入一个组件public @interface AutoConfigurationPackage &#123;&#125;//利用Registrar给容器中导入一系列组件//将指定的一个包下的所有组件导入进来？xxxApplication.java 所在包下。 @AutoConfigurationPackage注解是指定了默认的包规则，即在该包下的组件才可以被Springboot扫描后自动装配(注册)进IOC容器中。使用@import将AutoConfigurationPackages包下的Registrar类作为组件导入到容器中，然后使用Registrar中的方法批量完成组件的注册。 进入 源码后 Registrar.class debug registerBeanDefinitions 中去 IDEA ctrl + f8 可以知道 new PackageImports(metadata).getPackageNames() 对应的值是 com.tao.boot 包 所以可以说明 @AutoConfigurationPackage 会被SpringBoot自动扫描指定包(如果没有指定会使用默认扫描xxxApplication.java同级包下所有的bean)路径下的所有bean 并注册到IOC容器中 @Import(AutoConfigurationImportSelector.class)先理解源码怎么来的！！！ 先进入 AutoConfigurationImportSelector.class 类中 12345671、利用getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件2、调用List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类3、利用工厂加载 Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader)；得到所有的组件4、从META-INF/spring.factories位置来加载一个文件。 默认扫描我们当前系统里面所有META-INF/spring.factories位置的文件 spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF/spring.factories 按需开始自动配置项虽然我们有100多个场景1所有自动配置启动的时候默认全部加载。xxxAutoConfiguration按照条件装配规则(.@Conditional )，最终会按需配置 修改默认配置12345678910@Bean@ConditionalOnBean(MultipartResolver.class) //从IOC容器中找是否有这个类型组件@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)// 从IOC容器中找是否有 名为 multipartResolver 的组件public MultipartResolver multipartResolver(MultipartResolver resolver) &#123; //给@Bean标注的方式传入了对象参数，这个参数就会去容器中找 //Spring MVC MultipartResolver 防止有些用户配置文件上传解析器不符合规范 // Detect if the user has created a MultipartResolver but named it incorrectly return resolver;&#125;//在容器中加入了文件上传解析器 Spring Boot 默认会在底层配好所有组件。但是如果用户自己配置了组件，那就以用户的为先 123@Bean@ConditionalOnMissingBeanpublic CharacterEncodingFilter characterEncodingFilter() &#123;&#125; 总结： Spring Boot 先加载所有的自动配置类 xxxxAutoCongiguration 每个自动配置类按照条件进行生效，默认绑定配置文件指定的值 。 @EnableConfigurationProperties(xxxxProperties.class) 这些配置文件的值都是从 xxxx Properties.class 中去拿 生效的配置类就会给容器中装配很多的组件 只要容器中有这些组件，相当于这些功能就有了 只要用户有自己配置的，那么就以用户的优先 定制化配置 用户自己直接 使用@Bean替换底层的组件 12345678910111213141516171819@Configuration@EnableConfigurationProperties(ServerProperties.class)public class MyCharset &#123; private final Encoding properties; public MyCharset(ServerProperties properties) &#123; this.properties = properties.getServlet().getEncoding(); &#125; @Bean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new CharacterEncodingFilter(); filter.setEncoding(&quot;utf-8&quot;); filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE)); return filter; &#125;&#125; xxxxxAutoConfiguration —&gt; 自己定义的Bean里面拿值 用户去看这个组件获取的配置文件实某些值，去Spring Boot(application.properties)文件中修改这些值 1server.servlet.encoding.charset=utf-8 xxxxxAutoConfiguration —&gt; 组件 —&gt; xxxxProperties里面拿值 —-&gt; application.properties 最佳实践 引入场景依赖 去网上查找 官网查找 查看自动配置了哪些（选做） 自己分析，引入的场景对应的自动配置一般都生效了 配置文件(application.properties)中开启debug&#x3D;true 在 输出中有 Negative（不生效）\\Positive（生效） 是否需要修改 参照文档修改配置项 官网查找 自己分析， xxxx Properties绑定的配置文件有哪些配置项 自定义加入或者替换组件 使用 @Bean 、@Configuration 、….自定义配置 自定义器 xxxxCustomizer 简化开发","categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://example.com/tags/Spring-Boot/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Hello World","slug":"Hello World","date":"2022-10-27T17:01:01.000Z","updated":"2022-10-28T14:36:46.600Z","comments":true,"path":"2022/10/28/Hello World/","link":"","permalink":"http://example.com/2022/10/28/Hello%20World/","excerpt":"","text":"1System.out.println(&quot;Hello World&quot;); 你好，很高兴你看到了这篇博文，这是我的第一篇博文。（其实在之前我已经反复搭建了好几次博客，但是数据都丢失了。。。所以这算是第一篇了吧） 为什么要搭建博客搭建博客的好处挺多的，比如可以把写代码过程中的某些点写出来整理成一篇博文，也可以写点对事情什么的看法。让自己成为一个内容的生产者，也可以更好的回顾和积累自己的知识和思想。 为什么选择静态博客静态博客不需要额外去维护网站的运营（甚至是白嫖），博文存放在github等代码托管平台上，部署前上传，不需要担心数据丢失的问题。虽然静态博客需要去部署生成静态网页文件，但是对于大部分用户来说根本就没有那么多博文，速度完全可以接受 这个博客的主要内容？个人更偏向于记录日常写代码的部分技巧的，技术类的博客。自己的文笔和知识水平有限，也没法发散去聊其他东西（比如时事）。 结语我已经习惯当成内容的消费者太久了，没怎么想着去怎么生产内容，希望我能坚持下去运营着这个博客吧。","categories":[{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"}]}],"categories":[{"name":"java","slug":"java","permalink":"http://example.com/categories/java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://example.com/categories/Spring-Boot/"},{"name":"技术","slug":"技术","permalink":"http://example.com/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://example.com/tags/Spring-Boot/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"知识点","slug":"知识点","permalink":"http://example.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"}]}